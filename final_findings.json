[
  {
    "id": "PRRT_kwDOQ90Zis5q8I7o",
    "isResolved": false,
    "path": "tests/e2e/main.ts",
    "line": 155,
    "lastComment": "![medium](https://www.gstatic.com/codereviewagent/medium-priority.svg)\n\nFor improved robustness and to prevent unhandled promise rejections, it's a good practice to add a `.catch()` handler to your top-level `main()` function call. This will ensure any unexpected errors are caught and logged gracefully, and the process exits with a non-zero status code. This pattern is already used in `factory.ts`.\n\n```suggestion\nmain().catch((err) => {\n    console.error('\ud83d\udca5 A fatal error occurred in the E2E test runner:', err);\n    process.exit(1);\n});\n```",
    "author": "gemini-code-assist"
  },
  {
    "id": "PRRT_kwDOQ90Zis5q8Jqx",
    "isResolved": false,
    "path": "tests/e2e/runner.ts",
    "line": 22,
    "lastComment": "![high](https://www.gstatic.com/codereviewagent/high-priority.svg)\n\nUsing `rm -rf` on a programmatically constructed path is risky. If the `SANDBOX_ROOT` variable were misconfigured to an important directory, this command could cause significant data loss. It's best practice to add a safety check to ensure you are deleting from the intended directory before executing the command.\n\n```typescript\nexport async function cleanAllSandboxes() {\n    console.log(`\ud83e\uddf9 Cleaning sandbox root: ${SANDBOX_ROOT}`);\n    if (!SANDBOX_ROOT.endsWith('.sandbox')) {\n        console.error(`\u274c Refusing to clean non-sandbox directory: ${SANDBOX_ROOT}`);\n        return;\n    }\n    await $`rm -rf ${SANDBOX_ROOT}/*`.quiet().nothrow();\n}\n```",
    "author": "gemini-code-assist"
  },
  {
    "id": "PRRT_kwDOQ90Zis5q8Jqz",
    "isResolved": false,
    "path": "factory.ts",
    "line": 429,
    "lastComment": "![medium](https://www.gstatic.com/codereviewagent/medium-priority.svg)\n\nThe `shutdown()` function internally calls `process.exit()`, which terminates the process immediately. This means the promise returned by the `async shutdown` function will never resolve. Using `await` here is misleading as the code will never proceed past this line, and it suggests a behavior (waiting for completion) that cannot happen. It's better to call `shutdown(0)` directly to make the intent of terminating the process clear.\n\n```suggestion\n    shutdown(0);\n```",
    "author": "gemini-code-assist"
  },
  {
    "id": "PRRT_kwDOQ90Zis5q8Jq2",
    "isResolved": false,
    "path": "tests/e2e/main.ts",
    "line": 128,
    "lastComment": "![medium](https://www.gstatic.com/codereviewagent/medium-priority.svg)\n\nThe use of `Promise.all` can lead to an unhandled rejection if an error occurs during the setup of a scenario runner (e.g., in `new ScenarioRunner(scenario)`). This would crash the entire test suite and prevent the summary from being printed. To make the test runner more robust, you can wrap the logic inside the `map` with a `try...catch` block. This ensures that an error in one scenario doesn't stop others from running and being reported on.\n\n```suggestion\n    const results = await Promise.all(scenarios.map(async (scenario) => {\n        try {\n            const runner = new ScenarioRunner(scenario);\n            const result = await runner.run();\n            return { scenario, result };\n        } catch (e) {\n            const errorMsg = e instanceof Error ? e.message : String(e);\n            return { scenario, result: { success: false, logs: '', error: `Runner initialization failed: ${errorMsg}` } };\n        }\n    }));\n```",
    "author": "gemini-code-assist"
  },
  {
    "id": "PRRT_kwDOQ90Zis5q8Jq5",
    "isResolved": false,
    "path": "tests/e2e/runner.ts",
    "line": 63,
    "lastComment": "![medium](https://www.gstatic.com/codereviewagent/medium-priority.svg)\n\nThe code relies on `process.env.HOME` to mount the opencode configuration directory. If the `HOME` environment variable is not set, this will result in an invalid path like `undefined/.config/opencode`, causing the Docker command to fail cryptically. It's safer to conditionally add this volume mount only if `process.env.HOME` is defined.\n\n```typescript\n        const cmd = [\n            'docker', 'run',\n            '--name', this.containerName,\n            '-v', `${scenarioDir}:/app/target_project`,\n            ...(process.env.HOME ? ['-v', `${process.env.HOME}/.config/opencode:/root/.config/opencode`] : []),\n            '-v', '/var/run/docker.sock:/var/run/docker.sock',\n            // Pass minimal env vars needed\n            '-e', `OPENAI_API_KEY=${process.env.OPENAI_API_KEY || ''}`,\n            '-e', `ANTHROPIC_API_KEY=${process.env.ANTHROPIC_API_KEY || ''}`,\n            '-e', `GOOGLE_API_KEY=${process.env.GOOGLE_API_KEY || ''}`,\n            'wbe7/factory:latest',\n            ...this.config.args,\n            '--log-level', 'debug'\n        ];\n```",
    "author": "gemini-code-assist"
  },
  {
    "id": "PRRT_kwDOQ90Zis5q8Jq7",
    "isResolved": false,
    "path": "tests/e2e/validator.ts",
    "line": 35,
    "lastComment": "![medium](https://www.gstatic.com/codereviewagent/medium-priority.svg)\n\nThe `catch` block for reading `prd.json` is too broad. It catches any error and assumes the file is not found. This could mask other underlying issues, such as file permission errors, leading to confusing test failures. It's better to specifically check for a \"file not found\" error (e.g., `ENOENT`) and handle other errors differently, for instance by logging them more explicitly.\n\n```suggestion\n    try {\n        prdContent = await fs.readFile(path.join(scenarioDir, 'prd.json'), 'utf-8');\n    } catch (e) {\n        if (e instanceof Error && 'code' in e && e.code === 'ENOENT') {\n            prdContent = '(No prd.json found)';\n        } else {\n            prdContent = `(Error reading prd.json: ${e instanceof Error ? e.message : String(e)})`;\n        }\n    }\n```\n\n<details>\n<summary>References</summary>\n\n1. Avoid empty catch blocks that silently swallow all errors. If errors are expected and can be ignored (e.g., permission errors), log them at a debug level for easier debugging.\n</details>",
    "author": "gemini-code-assist"
  },
  {
    "id": "PRRT_kwDOQ90Zis5q8opD",
    "isResolved": false,
    "path": "tests/e2e/runner.ts",
    "line": 60,
    "lastComment": "![critical](https://www.gstatic.com/codereviewagent/critical.svg)\n\nThe E2E tests are configured to run against a hardcoded public Docker image (`wbe7/factory:latest`). This is a critical issue because it means the tests are not validating the code changes in this pull request, but rather whatever code is in the `:latest` tag of that image. The test suite should build a Docker image from the current source code and run the tests against that locally-built image to ensure the changes are actually being tested.\n\nYou could add a `docker-build` step to your `Makefile` and make the `full-e2e-test` target depend on it.\n\nExample `Makefile` changes:\n```makefile\n# In Makefile\n.PHONY: docker-build\ndocker-build:\n\tdocker build -t factory-pr-test:latest .\n\nfull-e2e-test: docker-build\n\t@echo \"\ud83d\ude80 Running Full E2E Test Suite...\"\n\tbun tests/e2e/main.ts\n```\nThen, you can use this new image tag here.\n\n```suggestion\n            'factory-pr-test:latest',\n```",
    "author": "gemini-code-assist"
  }
]
